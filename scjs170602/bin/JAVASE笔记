Java的三种技术架构:
JAVAEE：Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发；
JAVASE：Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础；
JAVAME：Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序；
JDK：Java Development Kit，java的开发和运行环境，java的开发工具和jre。
JRE：Java Runtime Environment，java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。
-------------------------------------------------java基础语法--------------------------------------------------------
变量的三要素:变量的数据类型，变量的名称，变量的初始值
基本数据类型(8种)：byte、short、int、long、float、double、char、boolean 
&和 &&区别： & ：无论左边结果是什么，右边都参与运算。&&:短路与，如果左边为false，那么右边不参数与运算。
|和||区别：|：两边都运算。||：短路或，如果左边为true，那么右边不参与运算。
break:作用于switch ，和循环语句，用于跳出当前循环体，或者称为结束。break语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。
continue:只作用于循环结构，继续循环用的。作用：结束本次循环，继续下次循环，回到循环体的开始位置。该语句单独存在时，下面不可以定义语句，执行不到。
函数的作用：1）、用于定义功能。2）、用于封装代码提高代码的复用性。注意：函数中只能调用函数，不能定义函数。
重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。
栈：存储的都是局部变量(函数中定义的变量，函数上的参数，语句中的变量),只要数据运算完成所在的区域结束，该数据就会被释放。
堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。1：每一个实体都有内存首地址值。2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。 3：垃圾回收机制。
-----------------------------------------------------OOP------------------------------------------------------
面向对象编程OOP(类->n个对象：属性,方法);类是具有相同属性和方法的一组对象的集合,类的三大特性:【封装，继承，多态】
成员变量和局部变量的区别：1：成员变量直接定义在类中。 局部变量定义在方法中，参数上，语句中。2：成员变量在这个类中有效。局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。
3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。
类的属性私有化(private)后，不能通过.属性直接来访问属性值，只能通过共有的setXX()方法和getXX()方法来设置和获取属性值，体现了封装的信息隐藏原则。
构造函数：1：该函数的名称和所在类的名称相同。2：不需要定义返回值类型。3：该函数没有具体的返回值。记住：所有对象创建时，都需要初始化才可以使用。构造方法不能被继承，所以不能重写，但是可以重载。
注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。
构造函数和一般函数有什么区别呢？1：两个函数定义格式不同。2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。 一般函数，是对象创建后，需要调用才执行，可以被调用多次。
封 装：隐藏对象的属性和实现细节，仅对外提供公共访问方式(体现了信息隐藏原则)
this:代表当前对象。1.this对象后面跟上 .调用的是成员属性和成员方法(一般方法);2.this对象后面跟上 ()调用的是本类中的对应参数的构造函数。
static修饰的变量和方法依赖类，不依赖对象，可直接使用类.变量或类.方法调用，且在加载程序时就已经初始化完成，且只有一份，所有实例共享,成员变量可以称为对象的特有数据，静态变量称为对象的共享数据
静态方法不可以调用非静态的变量和方法，但非静态的方法可以调用静态的方法和变量(因为静态修饰的变量和方法是最早初始化的),静态方法中不能使用this，super关键字
静态代码块:可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次(new 多个对象就只执行一次)。如果和主函数在同一类中，优先于主函数执行。
继 承:1：提高了代码的复用性。2：让类与类之间产生了关系，提供了另一个特征多态的前提。
重写:当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法,好像父类中的方法被覆盖掉一样。注意:父类的构造方法不能复写。
注意:重写发生在子父类中，子类重写父类的方法，方法名和参数列表必须相同，访问权限不能比父类更严格，返回值类型可以和父类相同或父类返回值类型的子类或 实现类，抛出的异常必须比父类的抛出的异常相同或父类的抛出的异常的子类。
-------------------------------------方法的重载与方法重写(复写)的区别-------------------------------------------------------
				位置		方法名	参数列表		返回值		访问修饰符
方法重写		子类与父类间	 相同		  相同			相同或是子类	不能比父类更小(严格)
方法重载		同类(本类)	 相同		不相同		无关			无关
---------------------------------------------------------------------------------------------------------------------
this：代表是本类类型的对象引用。super：代表是子类所属的父类中的内存空间引用。子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();
如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。
final:1：这个关键字是一个修饰符，可以修饰类，方法，变量。2：被final修饰的类是一个最终类，不可以被继承。3：被final修饰的方法是一个最终方法，不可以被复写,但可以重载。
4：被final修饰的变量是一个常量，只能赋值一次。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _连接.
-----------------------------访问修饰符总结(从小到大):private->default->protected->public ---------------------------------	
访问修饰符			同一类中			同一包中			子类			不同包中(其他)
private			  √				  ×				 ×				×
默认(default)	  √				  √				 ×				×
protected		  √				  √				 √				×
public 			  √				  √				 √				√
-------------------------------------------------------------------------------------------------------------------
抽象类(abstract):1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。2：抽象方法只定义方法声明，并不定义方法实现。3：抽象类不可以被创建对象(实例化)。
4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。抽象关键字abstract和哪些不可以共存？final ,private , static 
接 口(interface):类与类之间存在着继承关系，类与接口中间存在的是实现关系。继承用extends,实现用implements;接口可以被多实现,接口也可以多继承,用逗号隔开。
特点:1：接口是对外提供的规则。2：接口是功能的扩展。3：接口的出现降低了耦合性。在接口中，只能有静态常量(public static final可省略)和抽象方法(public abstract可省略)
关键字 instanceof:判断对象是否实现了指定的接口或继承了指定的类。格式：<对象 instanceof 类型> ，判断一个对象是否所属于指定的类型，是返回true，否则返回false。
-----------------------------------------------------抽象类和接口的区别-------------------------------------
1：抽象类只能被继承，而且只能单继承。接口需要被实现，而且可以多实现。 2：抽象类中可以定义非抽象方法，子类可以直接继承使用。接口中都有抽象方法，需要子类去实现。
3：抽象类使用的是  is a 关系。接口使用的 like a 关系。 4：抽象类的成员修饰符可以自定义。接口中的成员修饰符是固定的。全都是public的。
多 态:函数本身就具备多态性，某一种事物有不同的具体的体现(表现形式:方法的重载，可变参数，复写父类的方法，父类引用子类对象)
内部类：如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。
---------------------------------------------------异常(可抛性)---------------------------------------------------
异常分两种：1：编译时被检查的异常(check检查性异常)，要求程序员必须进行处理异常,否则不能运行程序。2：运行时异常(RuntimeException及RuntimeException的子类)，也就说这个异常是编译时不被检查的异常,程序员可以不处理异常,也能运行程序。
异常处理方式有两种：1、捕捉;2、抛出(通过throws关键字完成，格式：throws 异常类名,异常类名...这样标示后，调用者在使用该功能时，就必须要处理，谁调用谁处理。)
捕捉方法：try {
			需要被检测的代码；
		}catch(异常类 变量名){
			异常处理代码；
		}fianlly{
			一定会执行的代码；
		}
throw 和throws关键字的区别：throw用于抛出异常对象，后面跟的是异常对象；throw用在函数内。throws用于抛出异常类，后面跟的异常类名，可以跟多个，用逗号隔开。throws用在函数上。
自定义异常的步骤：1：定义一个子类继承Exception或RuntimeException，让该类具备可抛性。2：通过throw 或者throws进行操作。
如果父类或者接口中的方法没有抛出过异常，那么子类是不可以抛出异常的，如果子类的覆盖的方法中出现了异常，只能try不能throws。
如果这个异常子类无法处理，已经影响了子类方法的具体运算，这时可以在子类方法中，通过throw抛出RuntimeException异常或者其子类，这样，子类的方法上是不需要throws声明的。
父类object类中的==和equals()方法都是比内存地址的,要使==比地址,equals()方法比内容,所以一般要重写父类的equals()方法和hashCode()方法(String类就是重写了)
----------------------------------------------多线程-------------------------------------------------
进程：正在进行中的程序。其实进程就是一个应用程序运行时的内存分配空间。
线程：其实就是进程中一个程序执行控制单元，一条执行路径。进程负责的是应用程序的空间的标示。线程负责的是应用程序的执行顺序。
创建线程的第一种方式：继承Thread ，由子类复写run方法。1，定义类继承Thread类；2，目的是复写run方法，将要让线程运行的代码都存储到run方法中；3，通过创建Thread类的子类对象，创建线程对象；4，调用线程的start方法，开启线程，并执行run方法。
线程状态：被创建：start()；运行：具备执行资格，同时具备执行权；冻结：sleep(time),wait()―notify()唤醒；线程释放了执行权，同时释放执行资格；临时阻塞状态：线程具备cpu的执行资格，没有cpu的执行权；消亡：stop()
创建线程的第二种方式：实现一个接口Runnable。1，定义类实现Runnable接口。2，覆盖接口中的run方法（用于封装线程要运行的代码）。3，通过Thread类创建线程对象；
4，将实现了Runnable接口的子类对象作为实际参数传递给Thread类中的构造函数。为什么要传递呢？因为要让线程对象明确要运行的run方法所属的对象。5，调用Thread对象的start方法。开启线程，并运行Runnable接口子类中的run方法。
-----------------------------------------为什么要有Runnable接口的出现？---------------------------------------------
1：通过继承Thread类的方式，可以完成多线程的建立。但是这种方式有一个局限性，如果一个类已经有了自己的父类，就不可以继承Thread类，因为java单继承的局限性。因为实现Runnable接口可以避免单继承的局限性。
2：其实是将不同类中需要被多线程执行的代码进行抽取。将多线程要运行的代码的位置单独定义到接口中。为其他类进行功能扩展提供了前提。Runnable接口将线程要执行的任务封装成了对象。
-----------------------------------------------synchronized关键字（同步）------------------------------------------------
同步代码块：解决了线程安全问题。synchronized(对象) { 需要被同步的代码；} 		任意对象都可以，这个对象就是锁。
定义同步是有前提的：1，必须要有两个或者两个以上的线程，才需要同步。2，多个线程必须保证使用的是同一个锁。
同步代码块和同步函数的区别？同步代码块使用的锁可以是任意对象。同步函数使用的锁是this，静态同步函数的锁是该类的字节码文件对象。在一个类中只有一个同步，可以使用同步函数。如果有多同步，必须使用同步代码块，来确定不同的锁。所以同步代码块相对灵活一些。
同步死锁：通常只要将同步进行嵌套，就可以看到现象。同步函数中有同步代码块，同步代码块中还有同步函数。
join:阻塞并等待当前线程执行完成；interrupt:中断线程，并不会真正中断线程，而是给一个中断标志，该方法不能中断一个正在阻塞的线程，否则会抛出InterruptException；stop:直接停止线程，不安全，已过期
----------------------------------------wait，sleep，yield区别--------------------------------------------------------
wait：可以指定时间也可以不指定时间。不指定时间，只能由其他线程的notify(随机唤醒一个)或者notifyAll(唤醒所有)来唤醒。sleep：必须指定时间，时间到自动从冻结状态转成运行状态(临时阻塞状态)。
wait属于object类的方法：线程会释放执行权，而且线程会释放锁，需要在同步代码块中。Sleep属于Thread类的方法：线程会释放执行权，但不会释放锁。yield属于Thread类的方法：
退让，让同级别的线程优先调度，但不保证，有可能CPU会继续调度它，因为它只暂停一小段时间，暂停的时间不受控制，线程会释放执行权，但不会释放锁。
-------------------------------------------------死锁及其避免-------------------------------------------------------
死锁就是进程循环等待它方占有的资源而无限制的僵持下去的局面。
产生死锁的必要条件：1.互斥条件:就是一个资源同时只能有一个进程占有，不能有两个或是两个以上的占有。2.不可抢占条件:在一个进程所获取的资源在未使用完毕之前，资源申请者不能强行的从资源占有者手中抢夺资源。
3.占有申请条件：进程已经占有了一个资源，但是有申请新的资源；但是新申请的资源已经被别的进程占有了，此时该进程就会阻塞，但是在获取申请的资源之前他还会一直占有已占有的那个资源。
4.循环等待条件：存在一个循环等待序列，p1等待p2,p2等待p3,p3等待p1。形成一个进程循环等待。上述四个条件在死锁是会同时发送，也就是只要一个必要条件不通过，则就不会产生死锁。
-----------------------------------------------序列化----------------------------------------------
序列化:将Javabean对象从内存中写入到硬盘中的过程叫做序列化；反序列化：将硬盘中的文件写入到内存中形成对象的过程叫做反序列化；
********注意：加了static，transient关键字的属性不能被序列化
